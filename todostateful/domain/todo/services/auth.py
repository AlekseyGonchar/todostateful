from datetime import datetime, timedelta
from logging import Logger
from typing import Optional

from fastapi import HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from todostateful.shared import BaseDto
from todostateful.repositories import user

# this secret key is generated by `$ openssl rand -hex 32`
# these secret info should be kept in environment variable
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_schema: OAuth2PasswordBearer = OAuth2PasswordBearer(tokenUrl="/token")


class Token(BaseDto):
    access_token: str
    token_type: str


class TokenData(BaseDto):
    username: Optional[str] = None


class AuthService:
    def __init__(
        self,
        user_service: user.UserRepository,
        logger: Logger,
    ) -> None:
        self._user_service = user_service
        self._logger = logger

    async def get_current_user(self, token: str) -> user.User:
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            token_data = TokenData(username=username)
        except JWTError:
            raise credentials_exception

        if token_data.username is None:
            raise credentials_exception

        user = await self._user_service.get_user(username=token_data.username)

        if user is None:
            raise credentials_exception

        return user

    async def get_current_active_user(self, token: str) -> user.User:
        current_user = await self.get_current_user(token=token)

        if not current_user.activated:
            raise HTTPException(status_code=400, detail="Inactive user")

        return current_user

    @staticmethod
    def get_hashed_password(password: str) -> str:
        result: str = pwd_context.hash(password)
        return result

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        result: bool = pwd_context.verify(plain_password, hashed_password)
        return result

    async def authenticate_user(self, username: str, password: str) -> Optional[user.User]:
        user = await self._user_service.get_user(username)

        if not user:
            return None
        if not AuthService.verify_password(password, user.password):
            return None

        return user

    @staticmethod
    def create_access_token(username: str) -> str:
        expire = datetime.now() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        payload = {"sub": username, "exp": expire}
        result: str = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

        return result
